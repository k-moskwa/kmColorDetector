#ifndef KMCD_NO_LCD
#include "LiquidCrystal.h"
#endif

#if 0
#ifndef KMCD_NO_LCD
		char buf[5];
		if (SNDPL_FRAME_END_CODE == serialData) {
			lcdWrite('<');
			lcdSetCursor(0, 0);
		} else if (SNDPL_FRAME_START_CODE == serialData) {
			lcdWrite('>');
		} else if (0x00 == serialData) {
		lcdWrite('.');
		} else {
			itoa(serialData, buf, 16);
			if (0x00 == buf[1]) {
				lcdWrite('0');
			}
			lcdPrint(buf);
		}
#endif
#endif

#if 0
		static int cmd = 0;
		// playback test
		btnReset();
		dbToggle(DEBUG_BUTTON_PIN);
		lcdClear();
		lcdSetCursor(0, 1);
		swtStart(SWT_TIMER_1, BUTTON_CHECK_INTERVAL);

		// Player
		switch (cmd) {
			case 0 : {
				lcdPrint("0C");
				lcdFillSpacesToEndOfTheLine();
				//sndSetVolume(30);
				break;
			}
			case 1 : {
				lcdPrint("1C");
				lcdFillSpacesToEndOfTheLine();
				sndSetTrack(1);
				//sndQueryStatus();
				break;
			}
			case 2 : {
				lcdPrint("2C");
				lcdFillSpacesToEndOfTheLine();
				//sndQueryTracksCurrentTF();
				sndSetTrack(1);
				break;
			}
			case 3 : {
				lcdPrint("3C");
				lcdFillSpacesToEndOfTheLine();
				sndSetTrack(1);
				break;
			}
			case 4 : {
				lcdPrint("4C");
				lcdFillSpacesToEndOfTheLine();
				sndSetTrack(2);
				break;
			}
			case 5 : {
				lcdPrint("5C");
				lcdFillSpacesToEndOfTheLine();
				sndSetTrack(1);
				break;
			}
			case 6 : {
				lcdPrint("6C");
				lcdFillSpacesToEndOfTheLine();
				sndNext();
				break;
			}
			case 7 : {
				lcdPrint("7C");
				lcdFillSpacesToEndOfTheLine();
				sndNext();
				break;
			}
			case 8 : {
				lcdPrint("8C");
				lcdFillSpacesToEndOfTheLine();
				sndNext();
				break;
			}
		}
		cmd++;
		cmd %= 9;
#else


#ifndef KMCD_NO_LCD
	//char tmpBuffer[20];
	//sprintf(tmpBuffer, "R:%X, G:%X, B:%X", color.r, color.g, color.b);
	//sprintf(tmpBuffer, "H:%X, S:%X, V:%X ", color.h, color.s, color.v);
	//sprintf(tmpBuffer, "color:%X", colorNumber);
	//lcdPrint(tmpBuffer);
	//lcdSetCursor(0, 1);
#endif

	//swtStart(SWT_TIMER_1, BUTTON_CHECK_INTERVAL);

	

// tests
	/*
	settingsInit();
	RgbColor16_t black = settingsGetBlackReference();
	RgbColor16_t white = settingsGetWhiteReference();
	uint8_t colorsAvailable = settingsGetAvailableColorModels();
	HsvColor8_t *colorModels = settingsGetColorModels();

	colorSetBlackReference(black);
	colorSetWhiteReference(white);
	colorSetModels(colorModels, colorsAvailable);

	RgbColor16_t col = {.r = 0x5E8, .g = 0x384, .b = 0x400};
	RgbColor8_t normCol = colorNormalize(col);
	
	RgbColor16_t color1 = 	(RgbColor16_t){.r = 1000,  .g = 0,  .b = 0};
	RgbColor16_t color2 = 	(RgbColor16_t){.r = 0,  .g = 1000,  .b = 0};
	RgbColor16_t color3 = 	(RgbColor16_t){.r = 0,  .g = 0,  .b = 1000};

	HsvColor8_t hsvColor1 = colorRgbToHsv(colorNormalize(color1));
	HsvColor8_t hsvColor2 = colorRgbToHsv(colorNormalize(color2));
	HsvColor8_t hsvColor3 = colorRgbToHsv(colorNormalize(color3));

	uint8_t colorNumber = colorFindNearest(hsvColor1);
	colorNumber = colorFindNearest(hsvColor2);
	colorNumber = colorFindNearest(hsvColor3);


	uint32_t diff1 = colorDifferenceError(hsvColor1, hsvColor2);
	uint32_t diff2 = colorDifferenceError(hsvColor1, hsvColor3);

	RgbColor16_t blackLevel = {.r = 100, .g = 100, .b = 100};
	RgbColor16_t whiteLevel = {.r = 1000, .g = 1000, .b = 1000};
	colorSetBlackReference(blackLevel);
	colorSetWhiteReference(whiteLevel);
	RgbColor16_t color = 	{.r = 100, .g = 100, .b = 100};
	RgbColor8_t normalized;
	HsvColor8_t hsvColor;
	normalized = colorNormalize(color);

	uint8_t colorNumber;
	
	color = 	(RgbColor16_t){.r = 1000, .g = 1000, .b = 1000};
	normalized = colorNormalize(color);
	color = 	(RgbColor16_t){.r = 550,  .g = 550,  .b = 550};
	normalized = colorNormalize(color);
	color = 	(RgbColor16_t){.r =   0,  .g =   0,  .b =   0};
	normalized = colorNormalize(color);
	hsvColor = colorRgbToHsv(normalized);
	colorNumber = colorFindNearest(hsvColor);
	color = 	(RgbColor16_t){.r = 20000,  .g = 20000,  .b = 20000};
	normalized = colorNormalize(color);
	hsvColor = colorRgbToHsv(normalized);
	colorNumber = colorFindNearest(hsvColor);

	color = 	(RgbColor16_t){.r = 1000,  .g = 0,  .b = 0};
	normalized = colorNormalize(color);
	hsvColor = colorRgbToHsv(colorNormalize(color));
	colorNumber = colorFindNearest(hsvColor);
	color = 	(RgbColor16_t){.r = 0,  .g = 1000,  .b = 0};
	normalized = colorNormalize(color);
	hsvColor = colorRgbToHsv(colorNormalize(color));
	colorNumber = colorFindNearest(hsvColor);
	color = 	(RgbColor16_t){.r = 0,  .g = 0,  .b = 1000};
	normalized = colorNormalize(color);
	hsvColor = colorRgbToHsv(colorNormalize(color));
	colorNumber = colorFindNearest(hsvColor);
	*/

	//sndSetAckRequest(true);

	#if 1
#ifndef KMCD_NO_LCD
		uint8_t serialData = c;
		char buf[5];
		if (0xEF == serialData) {
			lcdWrite('<');
			lcdSetCursor(0, 0);
		} else if (0x7E == serialData) {
			lcdWrite('>');
		} else if (0x00 == serialData) {
		lcdWrite('.');
		} else {
			itoa(serialData, buf, 16);
			if (0x00 == buf[1]) {
				lcdWrite('0');
			}
			lcdPrint(buf);
		}
#endif
#endif

	//uint8_t colorNumber = colorFindNearest(colorRgbToHsv(colorNormalize(tscGetColor())));

	uint32_t colorDifferenceErrorHSV(HsvColor8_t sourceColor, HsvColor8_t modelColor) {
	uint32_t result = 0;
	result += (uint32_t)(colorPow2(abs((int16_t)sourceColor.s - (int16_t)modelColor.s)));
	result += (uint32_t)(colorPow2(abs((int32_t)sourceColor.v - (int32_t)modelColor.v)));
	int16_t hueDifference = abs((int16_t)sourceColor.h - (int16_t)modelColor.h);
	// comparison of hue values in radial space - difference cannot be higher than 180 degrees
	hueDifference = hueDifference > 0x80 ? 0xFF - hueDifference : hueDifference;
	result += (uint32_t)(colorPow2(hueDifference) >> 1);
	return result;
}


static HsvColor8_t *_colorModelsHsv;



#else
void colorSetModels(HsvColor8_t *colorModels, uint8_t colorModelsAvailable);
#endif


#else
void colorSetModels(HsvColor8_t *colorModels, uint8_t colorModelsAvailable) {
	_colorModels = colorModels;
	_colorModelsSizeOf = colorModelsAvailable;
}
#endif


#else
HsvColor8_t *settingsGetColorModels(void) {
	return _RAMsettings.colorModels;
}

HsvColor8_t settingsGetColorModel(uint8_t colorNumber) {
	return _RAMsettings.colorModels[colorNumber];
}

void settingsSetColorModel(uint8_t colorNumber, HsvColor8_t colorModel) {
	_RAMsettings.colorModels[colorNumber] = colorModel;
	if (_RAMsettings.availableColors < colorNumber) {
		_RAMsettings.availableColors = colorNumber;
	}
}
#endif

#else
typedef struct {
	char magic[8];
	RgbColor16_t blackReference;
	RgbColor16_t whiteReference;
	uint8_t availableColors;
	HsvColor8_t colorModels[KMCD_MAX_COLOR_MODELS];
} SettingsStruct;

static const SettingsStruct _PROGMEMsettings PROGMEM = {
	.blackReference = (RgbColor16_t){.r = 0x00D4, .g = 0x00B8, .b = 0x00D2}, 
	.whiteReference = (RgbColor16_t){.r = 0x057B, .g = 0x056E, .b = 0x0693},
	.availableColors = 6,
	.colorModels = 
	{
	// white
	(HsvColor8_t){.h = 0x00, .s = 0x00, .v = 0xFF}
	// black
	, (HsvColor8_t){.h = 0x00, .s = 0x00, .v = 0x00}
	// blue
	, (HsvColor8_t){.h = 0xE0, .s = 0x9A, .v = 0x65}
	// green
	, (HsvColor8_t){.h = 0xB9, .s = 0x77, .v = 0x60}
	// red
	, (HsvColor8_t){.h = 0xC8, .s = 0xFF, .v = 0xC0}
	// yellow
	, (HsvColor8_t){.h = 0xB9, .s = 0x1E, .v = 0xF0}
	/*
	// brown
	, (HsvColor8_t){.h = 0x30, .s = 0xF0, .v = 0x30}
	// orange
	, (HsvColor8_t){.h = 0x58, .s = 0x17, .v = 0xFF}
	*/
	}
};
#endif


void serSetTextColor(SerialColors color) {

}

void serSetBgColor(SerialColors color) {

}



//<esc>[{};...;{}m
/**
*/
typedef enum {
	// 30
	  SER_COL_BLACK
	// 31
	, SER_COL_RED
	// 32
	, SER_COL_GREEN
	// 33
	, SER_COL_YELLOW
	// 34
	, SER_COL_BLUE
	// 35
	, SER_COL_MAGENTA
	// 36
	, SER_COL_CYAN
	// 37
	, SER_COL_WHITE
} SerialColors;

/**
*/
typedef enum {
	// 0
	  SER_ATTR_RESET
	// 1
	, SER_ATTR_BRIGHT
	// 2
	, SER_ATTR_DIM
	// 3
	, SER_ATTR_UNDERSCORE
	// 4
	, SER_ATTR_BLINK
	// 7
	, SER_ATTR_REVERSE
	// 8
	, SER_ATTR_HIDDEN
} SerialAttributes;

/**
@param attribute
*/
void serSetAttribute(SerialAttributes attribute);

/**
@param color
*/
void serSetTextColor(SerialColors color);

/**
@param color
*/
void serSetBgColor(SerialColors color);